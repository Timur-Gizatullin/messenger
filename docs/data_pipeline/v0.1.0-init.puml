@startuml
participant Frontend
participant Backend
participant Postgres
participant Redis


== get dialogs with last message==
Frontend -> Backend: HTTP GET: /api/chats/ (auth_token)
Backend -> Postgres: PSQL: Get user by token

alt token not found
Postgres --x Backend: PSQL: Not found
Backend --x Frontend: HTTP: 401
end alt

Postgres --> Backend: PSQL: user
Backend -> Postgres: PSQL: Get chats by user.id
Postgres --> Backend: PSQL: chats
Backend -> Postgres: PSQL: Get last message by dialog.id foreach dialog
Postgres --> Backend: PSQL: last messages for each dialog
Backend --> Frontend: HTTP: chats with last message


== Create chat ==
Frontend -> Backend: HTTP POST: /api/chats/ (companion_user + crnt_user_token)
Backend -> Postgres: PSQL: get crnt_user by crnt_user_token
Postgres --> Backend: PSQL: crnt_user

alt token not found
Postgres --x Backend: PSQL: Not found
Backend --x Frontend: HTTP: 401
end alt

Backend -> Postgres: PSQL: get chats by crnt_user.id where dialog.is_dialog is true and chats doesn't contains companion user
Postgres --> Backend: None

alt chat exists
Postgres --> Backend: PSQL: chats
Backend --x Frontend: HTTP: 400
end alt

Backend -> Postgres: PSQL: create new chat
Postgres --> Backend: PSQL: chat
Backend --> Frontend: HTTP: chat


== Get messages with pagination ==
Frontend -> Backend: HTTP GET: /api/chats/{id}/messages/ (auth_token + limit + offset)
Backend -> Postgres: PSQL: Get user by auth_token

alt token not found
Postgres --> Backend: PSQL: Not found
Backend --> Frontend: HTTP: 401
end alt

Postgres --> Backend: PSQL: user
Backend -> Postgres: PSQL: get messages by chat.id with limit offset pagination filter
Postgres --> Backend: PSQL: messages
Backend --> Frontend: messages


== Add message to chat with real-time updating==
Frontend -> Backend: HTPP POST: /api/chat/{id}/ (text + pic) (auth_token)
Backend -> Postgres: PSQL: Get user by auth_token

alt token not found
Postgres --x Backend: PSQL: Not Found
Backend --x Frontend: HTTP: 401
end alt

Postgres --> Backend: PSQL: user
Backend -> Backend: Check if text or pic not None

alt text and pic is None
Backend --x Frontend: HTTP: 400
end alt

Backend -> Postgres: PSQL: get chat by id
Postgres --> Backend: PSQL: chat
Backend -> Postgres: PSQL: insert new message to chat.id
Postgres --> Backend: PSQL: message
Backend -> Frontend: WS: message
Frontend --> Backend: WS: ok
Backend --> Frontend: HTTP: 201


== Delete Message ==
Frontend -> Backend: HTTP Delete: /api/messages/{id}/ (auth_token)
Backend -> Postgres: PSQL: get user by auth_token

alt token not found
Postgres --x Backend: PSQL: Not found
Backend --x Frontend: HTTP: 401
end alt

Postgres --> Backend: PSQL: user
Backend -> Postgres: PSQL: Delete message by id
Postgres --> Backend: PSQL: ok
Backend --> Frontend: HTTP: 204


== Reply on message ==
Frontend -> Backend: HTTP POST: /api/messages/{id}/ (text + pic + reply_to_id)
Backend -> Postgres: PSQL: Get user by auth_token

alt token not found
Postgres --x Backend: PSQL: Not Found
Backend --x Frontend: HTTP: 401
end alt

Postgres --> Backend: PSQL: user
Backend -> Backend: Check if text or pic not None

alt text and pic is None
Backend --x Frontend: HTTP: 400
end alt

Backend -> Postgres: PSQL: Get reply_to_message by id
Postgres --> Backend: PSQL: reply_to_message
Backend -> Backend: new_message_model.reply_to is equal reply_to_message
Backend -> Postgres: PSQL: insert new message
Postgres --> Backend: PSQL: new_message
Backend --> Frontend: HTTP: new_message


== Forward message ==
Frontend -> Backend: HTTP PATCH: /api/messages/{id}/ (dialog_to_forward_id)
Backend -> Postgres: PSQL: Get user by auth_token

alt token not found
Postgres --x Backend: PSQL: Not Found
Backend --x Frontend: HTTP: 401
end alt

Postgres --> Backend: PSQL: user
Backend -> Postgres: PSQL: Get message by id
Postgres --> Backend: PSQL: message_to_forward
Backend -> Postgres: PSQL: get dialog_to_forward by dialog_to_forward_id
Postgres --> Backend: PSQL: dialog_to_forward
Backend -> Backend: dialog_to_forward.messages add message_to_forward
Backend -> Postgres: PSQL: Update entity
Postgres --> OK
Backend --> Frontend: HTTP: 204


== Registration ==
Frontend -> Backend: HTTP POST: /api/auth/sign_up/ (registration_model)
Backend -> Postgres: PSQL: Get user by registration_model.email

alt User with similar email exists
Postgres --x Backend: PSQL: User
Backend --x Frontend: HTTP: 400
end alt

Postgres --> Backend: PSQL: None
Backend -> Postgres: PSQL: Insert new_user
Postgres --> Backend: PSQL: new_user
Backend --> Frontend: HTTP: new_user


== login ==
Frontend -> Backend: HTTP POST: /api/auth/login/ (login_model)
Backend -> Postgres: PSQL: Get user by login_model.email
Postgres --> Backend: PSQL: user_data_to_compare
Backend -> Backend: Compare data from Frontend and Postgres

alt data is not similar
Backend --x Frontend: HTTP: 400
end alt

Backend --> Frontend: HTTP: Token


== Get users with pagination ==
Frontend -> Backend: HTTP GET: /api/users/ (limit + offset + auth_token)
Backend -> Postgres: PSQL: Get user by auth_token

alt token not found
Postgres --x Backend: PSQL: Not Found
Backend --x Frontend: HTTP: 401
end alt

Postgres --> Backend: PSQL: user
Backend -> Postgres: PSQL: Get users on limit + offset filter
Postgres --> Backend: PSQL:users
Backend --> Frontend: users

== Find user ==
Frontend -> Backend: HTTP GET: /api/users/ (user_to_find + auth_token)
Backend -> Postgres: PSQL: Get user by auth_token

alt token not found
Postgres --x Backend: PSQL: Not Found
Backend --x Frontend: HTTP: 401
end alt

Postgres --> Backend: PSQL: user
Backend -> Postgres: PSQL: Get user with filter string__contains = 'user_to_find'
Postgres --> Backend: PSQL: user
Backend --> Frontend: HTTP: user


== Upload profile pic ==
Frontend -> Backend: HTTP PATCH: api/users/{id} (pic_to_upload) (auth_token)
Backend -> Postgres: PSQL: Get user by auth_token

alt token is not found
Backend --x Frontend: HTTP: 404
end alt

Backend -> Backend: Update user_model
Backend -> Postgres: PSQL: Update entity
Backend --> Frontend: HTTP: 204
@enduml